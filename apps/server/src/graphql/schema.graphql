schema {
  query: Query
  mutation: Mutation
}

input CatchPokemonInput {
  nickname: String
  pokemonId: ID!
}

type CaughtPokemon implements Node {
  caughtAt: String!
  id: ID!
  nickname: String
  pokemon: Pokemon
  shiny: Boolean!
  stats: String!
  user: User
}

type ErrorResult {
  code: String!
  message: String!
}

type Mutation {
  catchPokemon(input: CatchPokemonInput!): CaughtPokemon @auth(role: "user")
  releasePokemon(input: ReleasePokemonInput!): ReleasePokemonResult @auth(role: "user")
  updateName(name: String!): User @auth(role: "user")
  updatePokemon(input: UpdatePokemonInput!): Pokemon @auth(role: "user")
  updateUser(input: UpdateUserInput!): UpdateUserResult @auth(role: "user")
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Pokemon implements Node {
  caughtPokemons(after: String, before: String, first: Int, last: Int): PokemonCaughtPokemonsConnection! @auth(role: "user")
  id: ID!
  name: String!
  primaryType: String!
  secondaryType: String
}

type PokemonCaughtPokemonsConnection {
  edges: [PokemonCaughtPokemonsConnectionEdge]
  pageInfo: PageInfo!
}

type PokemonCaughtPokemonsConnectionEdge {
  cursor: String!
  node: CaughtPokemon
}

type PokemonConnection {
  edges: [PokemonEdge]
  pageInfo: PageInfo!
}

type PokemonEdge {
  cursor: String!
  node: Pokemon
}

type Query {
  node(id: ID!): Node
  pokemon(id: ID!): Pokemon @auth(role: "user")
  pokemons(after: String, before: String, first: Int, last: Int, name: String): QueryPokemonsConnection
  user(username: String!): User @auth(role: "user")
  users(after: String, before: String, first: Int, last: Int, name: String): QueryUsersConnection @auth(role: "user")
  viewer: User
}

type QueryPokemonsConnection {
  edges: [QueryPokemonsConnectionEdge]
  pageInfo: PageInfo!
}

type QueryPokemonsConnectionEdge {
  cursor: String!
  node: Pokemon
}

type QueryUsersConnection {
  edges: [QueryUsersConnectionEdge]
  pageInfo: PageInfo!
}

type QueryUsersConnectionEdge {
  cursor: String!
  node: User
}

input ReleasePokemonInput {
  id: ID!
}

type ReleasePokemonResult {
  success: Boolean!
}

input UpdatePokemonInput {
  id: ID!
  name: String!
  primaryType: String!
  secondaryType: String
}

input UpdateUserInput {
  id: ID!
  name: String
  username: String
}

union UpdateUserResult = ErrorResult | User

type User implements Node {
  email: String @auth(self: true)
  id: ID!
  locale: String @auth(self: true)
  name: String!
  pokemons(after: String, before: String, first: Int, last: Int): UserPokemonsConnection!
  role: String! @auth(self: true)
  username: String
}

type UserConnection {
  edges: [UserEdge]
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String!
  node: User
}

type UserPokemonsConnection {
  edges: [UserPokemonsConnectionEdge]
  pageInfo: PageInfo!
}

type UserPokemonsConnectionEdge {
  cursor: String!
  node: CaughtPokemon
}